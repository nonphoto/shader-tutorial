<!DOCTYPE html>
<html>
    <head>
        <title>Shader Tutorial</title>
        <link rel="stylesheet" href="styles.css">
    </head>
    <body>
        <section>
            <h1>Shaders</h1>
        </section>
        <section id="intro">
            <p>
                WebGl is our interface with the GPU. It is challenging to use because its API is confusing. In this tutorial I want to demystify the process of getting a shader program running so you don't have to load a big framework like <a href="https://threejs.org/">Three</a> or <a href="http://www.pixijs.com/">Pixi</a>.
            </p>
            <p>
                Essentially, WebGL uses the graphics card to draw to the canvas.
            </p>
            <p>
                All geometry is composed of triangles. Triangles are great because any three points defines exactly one plane.
            </p>
        </section>
        <section id="part-0">
            <h2>0</h2>
            <h4>
                Setting up our site
            </h4>
            <ul>
                <li>
                    Create a very basic site with a canvas centered in the viewport.
                </li>
                <li>
                    Run a Javascript file called <a href="part-0/main.js">main.js</a> at the end of the page.
                </li>
                <li>
                    Request the vertex and fragment shaders using <span class="code">request</span> from <a href="util.js">util.js</a>
                </li>
            </ul>
        </section>
        <section id="part-1">
            <h2>1</h2>
            <h4>
                Initializing the context
            </h4>
            <ul>
                <li>
                    Create a new WebGl context for the canvas element.
                </li>
                <li>
                    Create new shader objects from the vertex and fragment shader sources.
                </li>
                <li>
                    Create a new WebGl program that uses the two shaders.
                </li>
                <li>
                    Clear the canvas using our context.
                </li>
            </ul>
            <p>
                The canvas should now be bright pink.
            </p>
        </section>
        <section id="part-2">
            <h2>2</h2>
            <h4>
                Creating the vertex and element buffers
            </h4>
            <p>
                We want the vertex shader to iterate over our vertex positions, but we haven't yet given it any data to work with.
            </p>
            <p>
                We use a <em>vertex buffer</em> to store our vertex positions, and an <em>element buffer</em> to store the order in which to traverse the vertices.
            </p>
            <p>
                Even though vertex positions are 3-dimensional vectors, both the vertex and element buffers are flat arrays. We will tell WebGL how to interpret the buffers later.
            </p>
            <ul>
                <li>
                    Create arrays for the vertices and indices called <span class="code">positions</span> and <span class="code">elements</span>
                </li>
                <li>
                    Create a <span class="code">vertexBuffer</span> and <span class="code">elementBuffer</span>, and populate them with the vertex positions and indices.
                </li>
            </ul>
        </section>
        <section id="part-3">
            <h2>3</h2>
            <h4>
                Drawing triangles to the screen
            </h4>
            <p>
                We have created buffers for our vertex data, now its time to convert the data into pixels in the canvas.
            </p>
            <p>
                The vertex shader receives the vertex positions from the vertex buffer in an <em>attribute</em>. An attribute is a variable that we declare in the vertex shader.
            </p>
            <p>
                First we write each element of the vertex buffer to an attribute we declared in the vertex shader. Later, we will manipulate the vertex in some way before returning it.
            </p>
            <p>
                When the vertex shader is finished processing all of the vertex data, the shader program rasterizes the resulting triangles. It uses the fragment shader to decide what color each pixel should be.
            </p>
            <ul>
                <li>
                    Get the memory location of the vertex position attribute and write the vertex buffer to it.
                </li>
                <li>
                    Run the vertex and fragment shaders by calling <span class="code">gl.drawElements</span>
                </li>
                <li>
                    Set <span class="code">gl_Position</span> to return each of the vertices without manipulating them.
                </li>
                <li>
                    Set <span class="code">gl_FragColor</span> to render bright blue for every fragment.
                </li>
            </ul>
            <p>
                The canvas is now bright blue.
            </p>
        </section>
        <section id="part-4">
            <h2>4</h2>
            <h4>
                Perspective projection
            </h4>
            <p>
                The entire canvas is now blue because the edges of the cube line up with the corners of the canvas.
            </p>
            <p>
                WebGL does not give you a 3d perspective by default; it just ignores the z axis. We need to do some math to project our 3d coordinates into the 2d space of the canvas.
            </p>
            <p>
                The easiest way to do this is using <em>matrix multiplication</em>. Simply put, matrices perform different transformations on vectors when you multiply them together.
            </p>
            <ul>
                <li>
                    Add a function <span class="code">perspective</span> that produces a new perspective matrix.
                </li>
                <li>
                    Translate the vertex position away from the origin of the scene using vector addition.
                </li>
                <li>
                    Project the 3d vertex into 2d space by multiplying it by the perspective matrix.
                </li>
            </ul>
            <p>
                Now you should see a blue square in the center of a pink canvas.
            </p>
        </section>
        <section id="part-5">
            <h2>5</h2>
            <h4>
                Model rotation
            </h4>
            <p>
                We rotate the model in the same way we performed the perspective projection, with matrix multiplication.
            </p>
            <ul>
                <li>
                    Add a function <span class="code">rotateY</span> that returns a new rotation matrix.
                </li>
                <li>
                    Rotate the model by multiplying each vertex by the rotation matrix.
                </li>
            </ul>
        </section>
        <section id="part-6">
            <h2>6</h2>
            <h4>
                Animation
            </h4>
            <p>
                We can animate our scene by re-drawing the frame 60 times per second, and passing in a different global time variable for each frame.
            </p>
            <p>
                WebGL supports passing global variables to shaders with <em>uniforms</em>. Uniforms are just constants that we set before running the vertex and fragment shaders.
            </p>
            <ul>
                <li>
                    Get the memory location of the time uniform in the vertex shader.
                </li>
                <li>
                    Start an animation loop using <code class="span">requestAnimationFrame</code>.
                </li>
                <li>
                    Write the current time to the uniform each frame.
                </li>
                <li>
                    Rotate the model by a product of the current time.
                </li>
            </ul>
            <p>
                The cube spins around the y axis now. Notice that the background is transparent because we aren't clearing the canvas each frame.
            </p>
        </section>
        <section id="part-7">
            <h2>7</h2>
            <h4>
                Color
            </h4>
            <p>
                We can add color to our cube by returning a different color for each pixel in the fragment shader.
            </p>
            <p>
                We can use a <em>varying</em> to pass information from the vertex shader to the fragment shader. In this case, we give each vertex a color.
            </p>
            <p>
                The varying will automatically interpolate between vertex values for the given fragment.
            </p>
            <ul>
                <li>
                    Create a new varying called <span class="code">v_color</span>.
                </li>
                <li>
                    Set the output color to the interpolated <span class="code">v_color</span>.
                </li>
            </ul>
            <p>
                Rainbow cube!
            </p>
        </section>
    </body>
</html>